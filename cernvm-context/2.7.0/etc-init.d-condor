#!/bin/bash
#
# condor	This script allows for starting and stopping Condor.
#
# chkconfig: 2345 98 10
# description: Condor is a high throughput computing batch processing
# 	       platform.
# processname: condor_master
# config: /etc/condor/condor_config
# pidfile: /var/run/condor/condor_master.pid

### BEGIN INIT INFO
# Provides: condor
# Required-Start: $local_fs $network $amiconfig-cernvm $amiconfig-hepix
# Required-Stop: $local_fs $network
# Short-Description: start and stop Condor
# Description: Condor HTC computing platform
### END INIT INFO

CONDOR_CONFIG="/etc/condor/condor_config"
export CONDOR_CONFIG

PATH="/opt/condor/bin:/opt/condor/sbin:$PATH"

# Source function library
. /etc/init.d/functions

# Source networking configuration
[ -f /etc/sysconfig/network ] && . /etc/sysconfig/network

# Source Condor configuration
[ ! -f /etc/sysconfig/condor ] && exit 0

. /etc/sysconfig/condor

[ -f /etc/cernvm/environment.conf ] && . /etc/cernvm/environment.conf

CONDOR_LOCALCONFIG=${CONFIG_CONDOR_LOCALCONFIG:=${CONDOR_CONFIG}.local}

sed -i 's|^LOCAL_CONFIG_FILE *=.*$|LOCAL_CONFIG_FILE = '"${CONDOR_LOCALCONFIG}"'|g' /etc/condor/condor_config 2> /dev/null

if [ "x$CONFIG_CONDOR_MASTER" = "x" ]
then
   CONFIG_CONDOR_MASTER=`hostname -f`
fi

JAVA=$(ls -1 /usr/lib/jvm/java-*-openjdk-*/bin/java | head -1) 2> /dev/null

CONFIG_CONDOR_USER=${CONFIG_CONDOR_USER:=condor}
CONFIG_CONDOR_GROUP=${CONFIG_CONDOR_GROUP:=$CONFIG_CONDOR_USER}

groupadd $CONFIG_CONDOR_GROUP > /dev/null 2>&1
useradd -m -g $CONFIG_CONDOR_GROUP $CONFIG_CONDOR_USER > /dev/null 2>&1

CONFIG_CONDOR_DIR=${CONFIG_CONDOR_DIR:=$(getent passwd $CONFIG_CONDOR_USER | cut -d: -f6)}

for dir in execute log spool 
do
  mkdir -p $CONFIG_CONDOR_DIR/$dir
done

chown -R $CONFIG_CONDOR_GROUP:$CONFIG_CONDOR_GROUP $CONFIG_CONDOR_DIR > /dev/null 2>&1
chmod -R 775 $CONFIG_CONDOR_DIR > /dev/null 2>&1

CONFIG_CONDOR_SLOTS=${CONFIG_CONDOR_SLOTS:=1}
CONFIG_CONDOR_SLOT_USER=${CONFIG_CONDOR_SLOT_USER:=$CONFIG_CONDOR_USER}

for var in $(seq $CONFIG_CONDOR_SLOTS)
do
     useradd -m -s /sbin/nologin -g $CONFIG_CONDOR_GROUP $CONFIG_CONDOR_SLOT_USER${var} > /dev/null 2>&1
     dir=$(getent passwd $CONFIG_CONDOR_SLOT_USER${var} | cut -d: -f6)
     chown -R $CONFIG_CONDOR_SLOT_USER${var}:$CONFIG_CONDOR_GROUP $dir > /dev/null 2>&1
     chmod -R 775 $dir > /dev/null 2>&1
done

[ ! -d /var/run/condor ] && mkdir -p /var/run/condor

chown -R $CONFIG_CONDOR_GROUP:$CONFIG_CONDOR_USER /var/run/condor

if [ x$CONFIG_CONDOR_MAP != x ] 
then
    echo "PASSWORD (.*) $CONFIG_CONDOR_MAP" > /etc/condor/canonical_map
fi

# The program being managed
prog=condor_master

lockfile=/var/lock/subsys/condor
pidfile=/var/run/condor/$prog.pid

# Check that networking is up
[ "${NETWORKING}" = "no" ] && exit 1


local_config()  {

  # If CONFIG_CONDOR_MASTER is an IP address, convert to FQDN
  local Grep_IPv4='^\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}$'
  local Grep_IPv6='^[a-fA-F0-9:]\+$'
  local IpToFqdn=0

  # Check for both IPv4 and IPv6
  echo "$CONDOR_MASTER" | grep -q "$Grep_IPv4"
  if [ $? != 0 ] ; then
    IpToFqdn=1
  else
    echo "$CONDOR_MASTER" | grep -q "$Grep_IPv6"
    if [ $? == 0 ] ; then
      IpToFqdn=1
    fi
  fi

  if [ $IpToFqdn != 0 ] ; then
    # Query nameservers from nsswitch.conf and consider the first FQDN
    CONFIG_CONDOR_MASTER=`getent hosts "$CONFIG_CONDOR_MASTER" | \
      cut -d' ' -f2- | grep -o '[^ ]\+\.[^ ]\+' | head -n1`
    # Fallback to localhost.localdomain in case of troubles
    if [ "$CONFIG_CONDOR_MASTER" == '' ] ; then
      CONFIG_CONDOR_MASTER='localhost.localdomain'
    fi
  fi

  CONFIG_CONDOR_ADMIN=${CONFIG_CONDOR_ADMIN:=root@$CONFIG_CONDOR_MASTER}
  CONFIG_CONDOR_HIGHPORT=${CONFIG_CONDOR_HIGHPORT:=9700}
  CONFIG_CONDOR_LOWPORT=${CONFIG_CONDOR_LOWPORT:=9600}
  CONFIG_CONDOR_UID_DOMAIN=${CONFIG_CONDOR_UID_DOMAIN:="*"}
  CONFIG_CONDOR_FILESYSTEM_DOMAIN=${CONFIG_CONDOR_FILESYSTEM_DOMAIN:=`hostname -f`}
  CONFIG_CONDOR_ALLOW_WRITE=${CONFIG_CONDOR_ALLOW_WRITE:="condor@*.*"}

  export CONDOR_IDS=`id -u $CONFIG_CONDOR_USER`"."`id -g $CONFIG_CONDOR_USER`

  {
    echo "CONDOR_HOST = $CONFIG_CONDOR_MASTER";
    echo "CONDOR_IDS = $CONDOR_IDS";
    if [ x`hostname -f` = x$CONFIG_CONDOR_MASTER ]
    then
      echo "DAEMON_LIST = COLLECTOR, MASTER, NEGOTIATOR, SCHEDD"
    else
      echo "DAEMON_LIST = MASTER, STARTD"
    fi;
    if [ x$CONFIG_COLLECTOR_NAME != x ] 
    then
      echo "COLLECTOR_NAME = $CONFIG_COLLECTOR_NAME"
    fi;
    echo "RELEASE_DIR = /opt/condor";
    echo "LOCAL_DIR = $CONFIG_CONDOR_DIR";
    echo "CONDOR_ADMIN = $CONFIG_CONDOR_ADMIN";
    echo "QUEUE_SUPER_USERS = root, $CONFIG_CONDOR_USER";
    echo "HIGHPORT = $CONFIG_CONDOR_HIGHPORT";
    echo "LOWPORT = $CONFIG_CONDOR_LOWPORT";
    echo "UID_DOMAIN = $CONFIG_CONDOR_UID_DOMAIN";
    echo "FILESYSTEM_DOMAIN = $CONFIG_CONDOR_FILESYSTEM_DOMAIN";
    echo "ALLOW_WRITE = $CONFIG_CONDOR_ALLOW_WRITE";
    if [ $CONFIG_CONDOR_SLOTS -gt 1 ]
    then
      echo "DEDICATED_EXECUTE_ACCOUNT_REGEXP = ${CONFIG_CONDOR_SLOT_USER}[0-9]+";
      echo "STARTER_ALLOW_RUNAS_OWNER = False";
    fi
    echo "JAVA=$JAVA";
    for var in $(seq $CONFIG_CONDOR_SLOTS)
    do
       echo "SLOT${var}_USER=$CONFIG_CONDOR_SLOT_USER${var}";
    done
    for var in $(echo $CONFIG_CONDOR_EXTRA_VARS | sed 's/,/ /g')
    do
       echo $var;
    done
  } > $CONDOR_LOCALCONFIG
}

start() {
    echo -n $"Starting Condor daemons: "
    local_config
    if [ x$CONFIG_CONDOR_SECRET != x ] 
    then
      /opt/condor/sbin/condor_store_cred -c add -p $CONFIG_CONDOR_SECRET > /dev/null
    fi
    rm -rf $lockfile
    sleep 5
    daemon /opt/condor/sbin/$prog -pidfile $pidfile
    RETVAL=$?
    echo
    [ $RETVAL -eq 0 ] && touch $lockfile
    sync
    return $RETVAL
}

stop() {
    echo -n $"Stopping Condor daemons: "
    killproc -p $pidfile $prog -QUIT
    RETVAL=$?
    echo
    wait_pid $pidfile 15
    if [ $? -ne 0 ]; then
	# If this happens during a restart the start is likely to see
	# condor still running and just return 0, which means when
	# condor exits it won't be restarted
	echo $"Warning: $prog may not have exited, start/restart may fail"
    fi
    [ $RETVAL -eq 0 ] && rm -f $lockfile
    return $RETVAL
}

reload() {
    echo -n $"Reloading Condor daemons: "
    kill -HUP `cat $pidfile` &>/dev/null
    RETVAL=$?
    echo_success
    echo
    return $RETVAL
}

#
# Determine if a process is running only by looking in a pidfile.
# There is no use of pidof, which can find processes that are not
# started by this script.
#
# ASSUMPTION: The pidfile will exist if the process does, see false
# negative warning.
#
# WARNING: A false positive is possible if the process that dropped
# the pid file has crashed and the pid has been recycled. A false
# negative is possible if the process has not yet dropped the pidfile,
# or it contains the incorrect pid.
#
# Usage: pid_status <pidfile> <lockfile>
# Result: 0 = pid exists
#         1 = pid does not exist, but pidfile does
#         2 = pid does not exist, but lockfile does
#         3 = pidfile does not exist, thus pid does not exist
#         4 = status unknown
#
pid_status() {
    pid=$(get_pid $1)
    case $? in
	1) return 3 ;;
	2) return 4 ;;
    esac

    ps $pid &>/dev/null
    if [ $? -ne 0 ]; then
	if [ -e $2 ]; then
	    return 2
	fi

	return 1
    fi

    return 0
}

#
# Wait for the pid in the pidfile to disappear, but only do so for at
# most timeout seconds.
#
# Usage: wait_pid <pidfile> <timeout>
# Result: 0 = pid was not found (doesn't exist or not accessible)
#         1 = pid still exists after timeout
wait_pid() {
    pid=$(get_pid $1)
    if [ $? -ne 0 ]; then
	return 0
    fi

    wait=0
    while [ $wait -lt $2 ]; do
	pid_status $1 /dev/null   # ingore lockfile
	if [ $? -ne 0 ]; then
	    return 0
        fi

	sleep 1
	wait=$((wait + 1))
    done

    return 1
}

#
# Retrieve pid from a pidfile
#
# Usage: get_pid <pidfile>
# Result: 0 = pid returned
#         1 = pidfile not found
#         2 = pidfile not accessible or didn't contain pid
# Stdout: pid
#
get_pid() {
    if [ -f $1 ]; then
	pid=`cat $1` &>/dev/null
	if [ $? -ne 0 -o -z "$pid" ]; then
	    return 2
	fi

	echo -n $pid
	return 0
    fi

    return 1
}


pid_status $pidfile $lockfile
running=$?

case "$1" in
    start)
	[ $running -eq 0 ] && exit 0
	start
	RETVAL=$?
	;;
    stop)
	[ $running -eq 0 ] || exit 0
	stop
	RETVAL=$?
	;;
    restart)
	[ $running -eq 0 ] && stop
	start
	RETVAL=$?
	;;
    try-restart)
	[ $running -eq 0 ] || exit 0
	stop
	start
	RETVAL=$?
	;;
    reload|force-reload)
	if [ $running -ne 0 ]; then
	    echo $"$0: error: $prog is not running"
	    exit 7
	fi
	reload
	RETVAL=$?
	;;
    status)
	if [ $running -ne 0 ]; then
	    case "$running" in
		1) echo $"$prog dead but pid file exists" ;;
		2) echo $"$prog dead but subsys locked" ;;
		3) echo $"$prog is stopped" ;;
		4) echo $"$prog status is unknown" ;;
	    esac

	    exit $running
	fi

	# WARNING: status uses pidof and may find more pids than it
	# should.
	status -p $pidfile $prog
	RETVAL=$?
	;;
    *)
	echo $"Usage: $0 {start|stop|restart|try-restart|reload|force-reload|status}"
	RETVAL=2
esac

exit $RETVAL
