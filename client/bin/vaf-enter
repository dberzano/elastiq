#!/bin/bash

#
# vaf-enter -- by Dario Berzano <dario.berzano@cern.ch>
#
# Part of virtual-analysis-facility.
#
# Enters a Bash shell with PoD + Experiment Software environment set.
#
# Both local (client) and remote experiment environment is set through a set of
# scripts. This is the order of execution:
#
# LOCAL ENVIRONMENT
#
#   common.before
#   local.before
#   local.conf
#   <PoD environment from $VafConf_LocalPodLocation/PoD_env.sh>
#   common.after
#   local.after
#
# PAYLOAD PREPARATION
#   The script is executed (not sourced!) locally (with VAF environment set) and
#   its stdout output will be prepended to the remote environment. As a matter
#   of fact it can be any executable, not just a script:
#
#   payload
#
# REMOTE ENVIRONMENT
#
#   <output of payload>
#   common.before
#   remote.before
#   remote.conf
#   common.after
#   remote.after
#
# All scripts are considered only if they exist. Scripts are searched for in the
# following paths, in order:
#
#   <dir of this script>/../etc
#   ~/.vaf
#
# System-wide scripts have precedence over user's (~/.vaf) scripts.
#
# The PoD_env.sh exists if PoD is correctly installed. A failure in loading PoD
# environment is fatal.
#

#
# Variables
#

# Set to 1 for debug
export Debug=0

# Exit codes
export ErrArgs=1
export ErrLocalCf=2

# Configuration search path (colon-separated)
export ConfPath=$(A=`dirname "$0"`;A=`dirname "$A"`;echo "$A/etc"):"$HOME/.vaf"

#
# Functions
#

# Wrapper to printout function
function _vaf_p() {
  echo -e "\033[1m$1\033[m"
}

# Printout only when debug is on
function _vaf_dp() {
  [ "$Debug" == 1 ] && _vaf_p "$@"
}

# Wrapper to pod-remote with proper environment
function vafctl() {
  local RetVal

  # BUG: --ssh-opt is ignored by current PoD (v3.12)!
  pod-remote \
    --remote "$VafUserHost:$VafConf_RemotePodLocation" \
    --env-local "$VafPodRemoteEnv" \
    "$@"

  return $RetVal
}

# Wrapper to pod-submit executed within pod-remote
function vafreq() {
  local Num="$1"
  let Num+=0
  if [ $Num -le 0 ] ; then
    _vaf_p 'Usage: vafreq <n_workers>'
  elif ! pod-info -s > /dev/null 2>&1 ; then
    # Check if pod-server is running
    _vaf_p 'Cannot contact PoD server. Did you start it?'
    _vaf_p 'Tip: you can (re)start it with:'
    _vaf_p '  vafctl --start'
    return 1
  else
    # pod-prep-worker is there to ensure that job payloads are up to date
    vafctl --command "pod-prep-worker ; pod-submit -r $VafConf_PodRms -n $Num"
  fi
}

# Wrapper to continuously ask pod-info for the number of workers
function vafcount() {
  local NumWorkers=0
  _vaf_p 'Updating every 5 seconds. Press Ctrl-C to stop monitoring...'
  while NumWorkers=`pod-info -n` ; do
    _vaf_p "[`date +%Y%m%d-%H%M%S`] $NumWorkers"
    sleep 5
  done
}

# Loads (sources) the specified configuration file. Usage:
#   LoadConf [-f] <source_cf>
#
# -f rises an error also when file is not found. Returns 0 on success, nonzero
# on error
function LoadConf() {
  HandleConf "$@" '' load
  return $?
}

# Appends a configuration file to another. Usage:
#   AppendConf [-f] <source_cf> <dest_cf>
#
# -f rises an error also when file is not found. Returns 0 on success, nonzero
# on error
function AppendConf() {
  HandleConf "$@" append
}

# Appends the output of an executable to a configuration file. Usage:
#   AppendOutputConf [-f] <executable> <dest_cf>
#
# -f rises an error also when file is not found. Returns 0 on success, nonzero
# on error
function AppendOutputConf() {
  HandleConf "$@" append-output
}

# Handles (appends/loads) a configuration file by raising errors if requested
# and printing out debug information. Used by AppendConf and LoadConf
function HandleConf() {

  local MustExist Cf Out Action

  if [ "$1" == '-f' ] ; then
    MustExist=1
    shift
  fi

  local Cf="$1"
  local Out="$2"
  local Action="$3"

  _vaf_dp "Looking for configuration file: $Cf"

  local Found=0

  if [ "${Cf:0:1}" == '/' ] ; then
    # Absolute path
    if [ -e "$Cf" ] ; then
      _vaf_dp " * $Cf: OK"
      Found=1
    else
      _vaf_dp " * $Cf: no"
    fi
  else
    # Relative path: append various search paths with priority
    local P OldIFS CfO CfP
    OldIFS="$IFS"
    IFS=':'
    for P in $ConfPath ; do
      CfP="$P/$Cf"
      if [ -e "$CfP" ] ; then
        Cf="$CfP"
        Found=1
        _vaf_dp " * $CfP: OK"
        break
     else
       _vaf_dp " * $CfP: no"
      fi
    done
    IFS="$OldIFS"
  fi

  if [ $Found == 1 ] ; then

    case "$Action" in
      load)
        _vaf_dp " * Loading"
        source "$Cf" || Err=1
      ;;
      append)
        _vaf_dp " * Adding"
        echo -e "\n### $Cf ###\n" >> "$Out"
        cat "$Cf" >> "$Out"
        echo '' >> "$Out"
      ;;
      append-output)
        _vaf_dp " * Adding output"
        echo -e "\n### Output of $Cf ###\n" >> "$Out"
        "$Cf" >> "$Out"
        echo '' >> "$Out"
      ;;
    esac

  else
    _vaf_dp " * Not found"
    [ "$MustExist" == 1 ] && Err=1
  fi

  if [ "$Err" == 1 ] ; then
    _vaf_p "Error loading $Cf"
    return 1
  fi

  return 0
}

# The main function
function Main() {

  # Parse user@host string
  if [ "$1" == '' ] ; then
    local Prog=`basename "$0"`
    _vaf_p "$Prog -- by Dario Berzano <dario.berzano@cern.ch>"
    _vaf_p "Enter the virtual analysis facility environment"
    _vaf_p ''
    _vaf_p "Usage: $Prog <user>@<host>"
    _vaf_p ''
    _vaf_p '<user> and <host> are mandatory. Connect to https://<host>/auth'
    _vaf_p 'from a browser with your Grid certificate to obtain credentials.'
    _vaf_p ''
    return $ErrArgs
  fi
  local ConnStr="$1"
  local Port=${ConnStr##*:}
  local VafUserHost=${ConnStr%:*}
  [ "$Port" == "$VafUserHost" ] && Port=''

  # Set prompt for environment shell
  PS1="pod://$VafUserHost"
  [ "$Port" != '' ] && PS1="$PS1:$Port"
  PS1="$PS1 [\W] > "

  local ConfPrefix="$HOME/.vaf"
  local Cf

  #
  # Local environment
  #

  # Before PoD
  local ConfLocalPre=( 'common.before' 'local.before' 'local.conf' )
  for Cf in ${ConfLocalPre[@]} ; do
    LoadConf "$Cf" || exit $ErrLocalCf
  done

  # Load PoD environment
  LoadConf -f "$VafConf_LocalPodLocation"/PoD_env.sh || exit $ErrLocalCf

  # After PoD
  local ConfLocalPost=( 'common.after' 'local.after' )
  for Cf in ${ConfLocalPre[@]} ; do
    LoadConf "$Cf" || exit $ErrLocalCf
  done

  # Prepare script for remote environment, including payload
  local VafPodRemoteEnv="/tmp/vaf_pod_remote_env_u$UID"
  echo -n '' > "$VafPodRemoteEnv"

  # Appending output of payload script (must be executable)
  AppendOutputConf 'payload' "$VafPodRemoteEnv"

  # Append other configuration scripts (will be sourced remotely and not
  # interpreted locally)
  local ConfRemote=(
    'common.before'
    'remote.before'
    'remote.conf'
    'common.after'
    'remote.after'
  )
  for Cf in ${ConfRemote[@]} ; do
    AppendConf "$Cf" "$VafPodRemoteEnv"
  done

  # Set some defaults
  [ "$VafConf_PodRms" == '' ] && VafConf_PodRms='condor'

  # Enter shell
  _vaf_p "Entering VAF environment: $VafUserHost"
  _vaf_p 'Remember: you are still in a shell on your local computer!'
  export VafPodRemoteEnv VafUserHost VafConf_PodRms
  export -f vafctl vafreq vafcount _vaf_p _vaf_dp
  exec env PS1="$PS1" bash --norc -i

}

#
# Entry point
#

Main "$@"
